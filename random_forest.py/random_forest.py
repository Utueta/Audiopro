"""
Audiopro Random Forest Brain v0.2.5
- Implements MLModelInterface for deterministic classification
- Handles feature vector normalization via Z-Score Scaler
- Manages persistent weight loading from .pkl artifacts
"""

import joblib
import logging
import numpy as np
from pathlib import Path
from typing import Tuple, Dict, Any

logger = logging.getLogger("system.brain")

class AudioBrain:
    """
    The Sentinel Brain: Performs real-time triage on audio features.
    Loads persistent weights to provide CLEAN/CORRUPT/SUSPICIOUS verdicts.
    """
    def __init__(self, weights_dir: str = "core/brain/weights"):
        self.weights_dir = Path(weights_dir)
        self.model = None
        self.scaler = None
        self.version = "v0.3.1"
        
        # SUSPICIOUS Trigger Thresholds
        self.lower_threshold = 0.35
        self.upper_threshold = 0.75
        
        self._load_weights()

    def _load_weights(self):
        """Loads the .pkl artifacts generated by retrain_model.py."""
        try:
            model_path = self.weights_dir / "random_forest_v0.3.pkl"
            scaler_path = self.weights_dir / "scaler_v0.3.pkl"
            
            if model_path.exists() and scaler_path.exists():
                self.model = joblib.load(model_path)
                self.scaler = joblib.load(scaler_path)
                logger.info(f"Sentinel Brain {self.version}: Weight artifacts loaded.")
            else:
                logger.warning("Sentinel Brain: Weights missing. Engaging Heuristic Safety.")
        except Exception as e:
            logger.error(f"Sentinel Brain: Critical loading failure: {e}")

    def classify(self, features: Dict[str, Any]) -> Tuple[str, float]:
        """Maps metrics to Three-State Industrial Logic."""
        suspicion_score = 0.0
        
        if self.model and self.scaler:
            try:
                raw_vector = np.array([[features['snr'], features['clipping']]])
                scaled_vector = self.scaler.transform(raw_vector)
                
                # Probability of Class 0 (Anomaly/Corrupt)
                probabilities = self.model.predict_proba(scaled_vector)[0]
                suspicion_score = float(probabilities[0]) 
            except Exception as e:
                logger.error(f"Inference Failure: {e}")
                suspicion_score = self._calculate_heuristic(features)
        else:
            suspicion_score = self._calculate_heuristic(features)

        verdict = self._map_score_to_verdict(suspicion_score)
        return verdict, suspicion_score

    def _calculate_heuristic(self, features: Dict[str, Any]) -> float:
        """Math-based fallback (SNR/Clipping)."""
        snr = features.get('snr', 20.0)
        clipping = features.get('clipping', 0)
        snr_factor = max(0.0, (20.0 - snr) / 20.0)
        clip_factor = min(1.0, clipping / 100.0)
        return (snr_factor * 0.6) + (clip_factor * 0.4)

    def _map_score_to_verdict(self, score: float) -> str:
        """Determines if the result triggers the Bridge (SUSPICIOUS)."""
        if score < self.lower_threshold:
            return "CLEAN"
        elif score > self.upper_threshold:
            return "CORRUPT"
        else:
            return "SUSPICIOUS"

    def hot_reload(self):
        """Reloads weights from disk after a retraining cycle."""
        self._load_weights()
